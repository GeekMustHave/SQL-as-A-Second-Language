= SQL as a Second Language
John Schuster <John.schuster@PhoenixWorkgroup.com>
v2.1n, 01/11/2019: Learning Guide
:source-highlighter: coderay
:coderay-css: class
:coderay-linenums-mode: inline
:Author: John HR Schuster
:Company: Phoenix Learning Labs
:toc: left
:toclevels: 4:
:imagesdir: ./images
:pagenums:
:numbered: 
:chapter-label: 
:experimental:
:icons: font
:docodir: ./doco
:sqldir: ./SQL
:resultdir: ./Results
:github: https://github.com/GeekMustHave/SQL-as-Second-Language
:linkattrs:
:seclinks:
:title-logo-image: ./images/create-doco_optum-cover.png

SQL as a Second Language (SASL) was a course that I taught many moons ago.
It is being revisited now to help answer some SQL questions brought up by those whose are taking
their SQL Skills to the next level.

A PDF version of this web site is available at this link:readme.pdf[ Link, window="_blank"]

[[top]]
== Introduction

This SQL As a Second Language version will use the Teradata SQL syntax.

.Examples
[quote, Bruce Lee,]
A teacher, a really good teacher, is never a giver of truth; he is a guide, a pointer to truth


<<<<
=== Chinook Database

The training database will be the Chinook database on music record sales.

Reference: https://github.com/lerocha/chinook-database

.Chinook Database Diagram
image::chinook-diagram.png[Chinook Database Diagram, align='center']

==== Chinook Business Rules

. Each *Artist* has 1 or more *Albums*
. Each *Album* has just 1 *Artist*
. Each *Album* has 1 or more *Tracks*
. Each *Track* has just 1 *Genre*
. Each *Track* has just 1 *Media Type*
. *Tracks* have playtime measured in milliseconds
. *Tracks* have disk space measured in bytes
. Each *Employee* has just 1 Manager, who is also an *Employee*
. Each *Customer* has 1 or more *Invoices*
. Each *Customer* has just 1 `support rep` who is an *Employee*
. Each *Invoice* has 1 or more *Invoice Lines*
. Each *Invoice Line* is related to just 1 *Track*
. *Invoices* span 2014 - 2018
. Each *Playlist* has 1 or more *Tracks*
. Not all *Genre* have *Tracks*
. Not all *Employees* who are `support reps` have customers

NOTE: The `Chinook` database will be known as the `DCH_Training` located on the `DRBC` server. 
 

=== Database Objects

In this document the term `Database Object` is used to indicate one of the following Teradata database elements.

* Table (All types)
* View
* Stored Procedure
* Macro

The reason for the term `Database Object` is to eliminate the confusion that can occur when objects change.  
(IE: A view you created is materialized into a table, a query you wrote is changed into a store procedure)

=== SQL Query Tools

There are a variety of SQL tools that can be used to develop and utilize the Teradata database.

* Teradata SQL Assistant - Included in the Teradata Tools and Utilities installation package
* Teradata Studio - Available as a separate download
* Database 5 Pro - Intuitive multiple database manager, portable (Authors preference)
* DBeaver - Free, open source, multi-platform universal database tool

NOTE: Many of the screen captures will be done using Database 5 Pro.




////
**********************************************************************
   ____                  _   _                 
  / __ \                | | (_)                
 | |  | |_   _  ___  ___| |_ _  ___  _ __  ___ 
 | |  | | | | |/ _ \/ __| __| |/ _ \| '_ \/ __|
 | |__| | |_| |  __/\__ \ |_| | (_) | | | \__ \
  \___\_\\__,_|\___||___/\__|_|\___/|_| |_|___/                                            
***********************************************************************
////
<<<<
== Questions

To ask a *New question* to be added to this list, please email it to john.schuster@PhoenixWorkgroup.com. 

[qanda]
How can I get a count of the number of rows in some of the tables of a database?::
  View this query <<tableCounts>>

How can a get a list of the objects (Tables, View, Procedures) for a specific database?::
  View This query <<dbObjects>>

How can I find out the columns and metadata about a specific object (Table, View)?::   
  View this query <<tableColumns>>

How can I find where a specific column exist in a database?::
  View this query <<findColumn>>

How do I Join two tables together?::
  View this query <<joinQueryPartB>>  

How do I restrict the results by a column that `contains` some string?::
    View this query <<joinQueryPartC>>  

How do I select or restrict a date column by month, day or year?::
    View this query <<dateFilters>>

How do I sort the results by multiple columns?::
    View this query <<joinQueryPartC>>      

How do I use a sub-query to collect information?::
    View this query <<derivedTable1PartA>>

How do I use a sub-query to reduce or filter information?::
    View this query <<derivedTable2A>>    

When do I use the `having` clause?::
    View this query <<derivedTable2PartD>>    

When is it a good idea to use a `view`?::
    Visit this query <<createView>>    

When do I use a `inner` join versus an `outer` join?::
    Visit this query <<joinTypes>>   

How do a do a Running Total (Cumulative Sum)?::
    View this query <<dateFilters>>   

How can a do a ranking of the results?::


How can I best use "Prompts" in SQL Assistant?::
  unlinked





////
************************************************************
   ____                  _           
  / __ \                (_)          
 | |  | |_   _  ___ _ __ _  ___  ___ 
 | |  | | | | |/ _ \ '__| |/ _ \/ __|
 | |__| | |_| |  __/ |  | |  __/\__ \
  \___\_\\__,_|\___|_|  |_|\___||___/
                                     
************************************************************
////
<<<<
== Queries

The queries in this document are not presented in any particular order.

These queries were constructed to answer specific questions from the students.

Whenever possible the actual SQL query statement is shown and can be downloaded. 
These queries can be the starting point for learning how to perform some function.

There are numbered call-outs on the SQL queries which are defined at the end of the query.
These call-outs are used to help highlight techniques or direct attention to subject matter.

The results of each query are shown and may vary slightly from the edition of the Chinook database you are using.

NOTE: If the query does not contain an `order by` clause then the results come back in a random order.
TThis is normal for the Teradata database.




<<<<
//// 
******************  tableCounts   tableCounts   tableCounts   tableCounts   
////
[[tableCounts]]
=== tableCounts

.SQL Example
[source,sql,linenums]
----
include::{sqldir}/0001-tableCounts.sql[]
----
<1> First query in union determine sizes and names of columns.
<2> count(*)  is an aggregate function
<3> Order by can be by the ordinal number of the column (Column 1 is tableName, Column 2 is Rows)

SQL download link link:{sqldir}/0001-tableCounts.sql[ click here]

.Results
[options='header']
,===
include::{resultdir}/0001-tableCounts.csv[results]
,===

NOTE: Your table counts may vary from this example as the Chinook database is updated to help with lesson content.

.Commenting your SQL
image::quote-comment.png[Commenting your SQL, align='center']

Back to <<top>>.





<<<<
//// 
******************  dbObjects    dbObjects    dbObjects    dbObjects    
////
[[dbObjects]]
=== dbObjects

.SQL Example
[source,sql,linenums]
----
include::{sqldir}/0002-dbObjects.sql[]
----

SQL download link link:{sqldir}/0002-dbObjects.sql[ click here]

.Results
[options='header']
,===
include::{resultdir}/0002-dbObjects.csv[results]
,===

NOTE: Your database objects may vary from this example as the Chinook database is updated to help with lesson content.

Back to <<top>>.




<<<<
//// 
******************  tableColumns    tableColumns    tableColumns    tableColumns    tableColumns    
////  
[[tableColumns]]
=== tableColumns
  
.SQL Example
[source,sql,linenums]
----
include::{sqldir}/0003-TableColumns.sql[]
----
 
SQL Download link link:{sqldir}/0003-TableColumns.sql[ click here]
 
.Results
[options='header']
,===
include::{resultdir}/0003-tableColumns.csv[Results]
,===

NOTE: ColumnType defined the data type of a column.
Reference: <<ColumnType>>
 
Back to <<top>>.
 




//// 
******************  findColumns   findColumns   findColumns   findColumns       
////    
<<<<
[[findColumn]]
=== findColumn
  
.SQL Example
[source,sql,linenums]
----
include::{sqldir}/0004-findColumns.sql[]
----
 
SQL Download link link:{sqldir}/0004-findColumns.sql[ click here]
 
.Results
[options='header']
,===
include::{resultdir}/0004-findColumns.csv[Results]
,===
 
NOTE: The ColumnType identifies the data type of the column.
Reference: <<Column Type>>

Back to <<top>>.
 




//// 
******************  joinQueryA   joinQueryA  joinQueryA  joinQueryA  joinQueryA         
////    
<<<<
[[joinQueryPartA]]
=== joinQuery Part A

*Objective:* Get a list of tracks from the *Artist* `Aerosmith` 
where the *Composer* is `Joe Perry`.

*Approach:* Begin with a simple query to get one element of the objective.
In this query we want to get the *ArtistID* for `Aerosmith`
  
.SQL Example
[source,sql,linenums]
----
include::{sqldir}/0005a-joinQuery.sql[]
----
<1> Column alias, notice name is `artistName` 
<2> Table alias, use alias on every instance of columns from that table
 
SQL Download link link:{sqldir}/0005a-joinQuery.sql[ click here]
 
.Results
[options='header']
,===
include::{resultdir}/0005a-joinQuery.csv[Results]
,===
 
Back to <<top>>.
 




//// 
******************  joinQueryB   joinQueryB  joinQueryBA  joinQueryBA  joinQueryB         
////   
<<<<
[[joinQueryPartB]]
=== joinQuery Part B


*Objective:* Get a list of tracks from the *Artist* `Aerosmith` 
where the *Composer* is `Joe Perry`.

*Approach:* Add on to the initial query to get a list of all the *Albums* for the *Artist* `Aerosmith`
  
.SQL Example
[source,sql,linenums]
----
include::{sqldir}/0005b-joinQuery.sql[]
----
<1> Column alias, notice name is `artistName` 
<2> Table alias, use alias on every instance of columns from that table
<3> The common column used to join the two tables together
 
SQL Download link link:{sqldir}/0005b-joinQuery.sql[ click here]
 
.Results
[options='header']
,===
include::{resultdir}/0005b-joinQuery.csv[Results]
,===
 
Back to <<top>>.





//// 
******************  joinQueryC   joinQueryC  joinQueryC  joinQueryC  joinQueryC         
////   
<<<<
[[joinQueryPartC]]
=== joinQuery Part C

*Objective:* Get a list of tracks from the *Artist* `Aerosmith` 
where the *Composer* is `Joe Perry`.

*Approach:* Complete the request by joining the `Title` table and a row restriction
using the `like` with the wildcard `%` character.
  
  
.SQL Example
[source,sql,linenums]
----
include::{sqldir}/0005c-joinQuery.sql[]
----
<1> Column alias, notice name is `artistName` 
<2> Table alias, use alias on every instance of columns from that table
<3> The common column used to join the two tables together
<4> The `like` with wildcard character `%` used on `Composer` column
<5> The order by has both actual column name `AL.AlbumTitle` and
an alias column `trackName`
<6> Shows alternative method of `order by` using ordinal column numbers
 
SQL Download link link:{sqldir}/0005c-joinQuery.sql[ click here]
 
.Results
[cols="^2,^2,^2,4,4,4,6" options='header']
,===
include::{resultdir}/0005c-joinQuery.csv[Results]
,===
 
Back to <<top>>.



<<<<
[[joinTypes]]

=== Join Types

The relationships between database objects are defined using `join` statements.

Two database objects are joined using one or more common columns between them.

==== Inner Join

An `Inner Join` can be used when you know there is at least one row in each of the two tables being joined.
The business rules or the data model can help define when this relationship occurs.

An `Inner Join` can be used to restrict/filter a large amount of rows from one table by a limited number of rows in the second table.

An `Inner Join` can be used to replace a `where` clause with a list of values or a sub-query.
The `Inner Join` can be much more performant than a `where` clause when there are a large number of restriction/filter rows.

==== Outer Join

* An `Outer Join` can be used when you know that there may no or is not one row in each of the tables being joined.
* An `Outer Join` returns *ALL* of the rows from one table and any matching rows from the second table.
* All `Outer Joins` has a direction, left outer join or right outer join.
Think of it as one object on the left and the second object on the right.
* The first `Select` object in the query is the `Left` object by default.
* The outer joined object is the `right` object.
* The direction of the outer join determines which object is the *All* object
* A `Right Outer Join` returns *ALL* the rows from the object on the *RIGHT* and any matching rows from the left object.
* A `Left Outer Join` returns *ALL* the rows from the object on the *LEFT* and any matching rows from the right object.
* The `on` clause of the join does *NOT* indicate the direction of the join.
  `on G.GenreID = T.GenreID` and `on T.GenreID = G.GenreID` 


.Right Outer Join
image::outerJoinRight.png[Right Outer Join, align='center']
 
The same query above could be written reversing the order in which the objects are referenced to show a Left Outer join.

.Left Outer Join
image::outerJoinLeft.png[Left Outer Join, align='center']
 
The following set of queries show how the results of a query can change due to the direction of the `Outer Join`.

//// 
***********************************************************************
GENRE LIST    GENRE LIST    GENRE LIST    GENRE LIST    GENRE LIST    
***********************************************************************  
////

The following query returns a list of all Genres, there should be 28 Genres.  

.Genre List
[source,sql,linenums]
----
include::{sqldir}/0009-joinTypes.sql[lines="1..24"]
----
<1> Column alias
<2> Alternative method to order by using `Ordinal` position
not recommended
 
SQL Download link link:{sqldir}/0009-joinTypes.sql[ click here]
 
.Results for Genre List
[options='header']
,===
include::{resultdir}/0009a-genreList.csv[Results for Genre List]
,===
 
Back to <<top>>.

//// 
***********************************************************************
INNER JOIN   INNER JOIN  INNER JOIN  INNER JOIN  INNER JOIN  INNER JOIN
***********************************************************************  
////

The following query shows the results when a `Inner Join` is used.

There are only 25 Genres in the result as 3 genres have no tracks related to them.

.Inner Join Example
[source,sql,linenums]
----
include::{sqldir}/0009-joinTypes.sql[lines="1..15,26..42"]
----
<1> Column Alias
<2> Aggregate column with alias
<3> Join (Inner)
<4> Column alias in group by and order by

 
SQL Download link link:{sqldir}/0009-joinTypes.sql[ click here]
 
.Results for Inner Join
[options='header']
,===
include::{resultdir}/0009b-genreTrackCount-inner.csv[Results for Inner Join]
,===

NOTE: The Genres `Club`, `Dub Step`, `Trance` are not in the results because the have no tracks related to them.
 
Back to <<top>>.

//// 
***********************************************************************
RIGHT OUTER   RIGHT OUTER   RIGHT OUTER   RIGHT OUTER   RIGHT OUTER   
***********************************************************************  
////


The following query shows the results when a `Right Outer Join` is used.

NOTE: This query is different from the one below, note which table is selected first.

.Right Outer Join Example
[source,sql,linenums]
----
include::{sqldir}/0009-joinTypes.sql[lines="1..15,44..60"]
----
<1> Column Alias
<2> Aggregate column with alias
<3> Join (Right Outer)
<4> Column alias in group by and order by


NOTE: By default the first table in the select is the `Left` table, in this example it is the `Track` table.  The `joined` table is the `Right` table and in this example it is the `Genre` table.  Since this is a `Right` outer join all the rows from the `Right` table (Genre) are returned with any matching rows from the `Left` table (Tracks).
 
SQL Download link link:{sqldir}/0009-joinTypes.sql[ click here]
 
.Results for Right Outer Join
[options='header']
,===
include::{resultdir}/0009c-genreTrackCount-leftOuter.csv[Results for Right Outer Join]
,===

NOTE: All 28 Genres are returned in the results.  The Genres `Club`, `Dub Step`, `Trance` are included and have a zero (0) trackCount.

Back to <<top>>.

//// 
***********************************************************************
LEFT OUTER    LEFT OUTER   LEFT OUTER   LEFT OUTER   LEFT OUTER    
***********************************************************************  
//// 

The following query shows the results when a `Left Outer Join` is used.

NOTE: This query is different from the one above, note which table is selected first.

.Left Outer Join Example
[source,sql,linenums]
----
include::{sqldir}/0009-joinTypes.sql[lines="1..15,62..77"]
----
<1> Column Alias
<2> Aggregate column with alias
<3> Join (Left Outer)
<4> Column alias in group by and order by


NOTE: By default the first table in the select is the `Left` table, in this example it is the `Genre` table.  The `joined` table is the `Right` table and in this example it is the `Track` table.  Since this is a `Right` outer join all the rows from the `Left` table (Genre) are returned with any matching rows from the `Right` table (Tracks).
 
SQL Download link link:{sqldir}/0009-joinTypes.sql[ click here]
 
.Results for Left Outer Join
[options='header']
,===
include::{resultdir}/0009d-genreTrackCount-rightOuter.csv[Results for Right Outer Join]
,===

NOTE: All 28 Genres are returned in the results.  The Genres `Club`, `Dub Step`, `Trance` are included and have a zero (0) trackCount.

Back to <<top>>.



//// 
******************  derivedTable1A  derivedTable1A  derivedTable1A  derivedTable1A      
////   
<<<<
[[derivedTable1PartA]]
=== derivedTable 1 - Part A

*Objective:* Get a list by Artist that includes number of albums, number of tracks, total artist minutes and average minutes per track.

*Approach:* Use a set of derived queries (aka sub-queries) to get the parts of the request and assemble the parts together in the main query.

This collection approach is typically used when the parts being collected come from varied databases or putting them in a single query makes it difficult to compose the query.

.derivedTable Collection
image::derivedTablesCollection.png[Collection, align='center']

Part A gets the number of albums by  artist. 
It is the (Album Part) we need for the main query.

NOTE: This request could be done using a single query.  The derived tables are being used here, 
to show how they can be used to build parts of the results, that are assembled in a main query later.

NOTE: Derived Tables are also know as sub-queries.  
  
  
.SQL Example
[source,sql,linenums]
----
include::{sqldir}/0006a-derivedTable.sql[]
----
<1> Column Alias
<2> Aggregate `Count` function
<3> Table alias
<4> Common column to join two tables
<5> Any non-aggregate column must be included in `group by`
 
SQL Download link link:{sqldir}/0006a-derivedTable.sql[ click here]
 
.Results
[cols="10,10" options='header']
,===
include::{resultdir}/0006a-derivedTable.csv[Results,lines=1..20]
,===

NOTE: Only 20 rows of the result being shown.  The result set has 204 rows, one for each artist.
 
Back to <<top>>.
 



//// 
******************  derivedTable1B  derivedTable1B  derivedTable1B  derivedTable1B      
//// 
<<<<
[[derivedTable1PartB]]
=== derived Table 1 -Part B

*Objective:* Get a list by Artist that includes number of albums, number of tracks, total artist minutes and average minutes per track.

*Approach:* Use a set of derived queries (aka sub-queries) to get the parts of the request and assemble the parts together in the main query.

This collection approach is typically used when the parts being collected come from varied databases or putting them in a single query makes it difficult to compose the query.

.derivedTable Collection
image::derivedTablesCollection.png[Collection, align='center']

This part gets the number of tracks by artist and calculates the number of minutes total and average minutes per track from the milliseconds.  It is the second part (Tracks Part) we need for the main query.

NOTE: This request could be done using a single query.  The derived tables are being used here, 
to show how they can be used to build parts of the results, that are assembled in a main query later.

NOTE: Derived Tables are also know as sub-queries.
  
.SQL Example
[source,sql]
----
include::{sqldir}/0006b-derivedTable.sql[]
----
 

SQL Download link link:{sqldir}/0006a-derivedTable.sql[ click here]
 
.Results
[options='header']
,===
include::{resultdir}/0006b-derivedTable.csv[Results,lines=1..20]
,===
<1> This calculated or derived field is the sum of time (Milliseconds) for all tracks for this artist.
Dividing by 60,000.00 translates this into minutes.  
<2> This calculated or derived field is the average of the time (Milliseconds) for all tracks for this artist.
Dividing by 60,000.00 translate this into minutes.

NOTE: Notice that the division was done using a fractional number 60000.00 which returns the results with two decimal points of precision.  If we had used an integer number 60000 we would have gotten an whole number back and lost the two decimal points of precision.

NOTE: Only 20 rows of the result being shown.  The result set has 204 rows, one for each artist.
 
Back to <<top>>.





//// 
******************  derivedTable1C  derivedTable1C  derivedTable1C  derivedTable1C      
////
<<<<
[[derivedTable1PartC]]
=== derivedTable 1 - Part C

*Objective:* Get a list by Artist that includes number of albums, number of tracks, total artist minutes and average minutes per track.

*Approach:* Use a set of derived queries (aka sub-queries) to get the parts of the request and assemble the parts together in the main query.

This collection approach is typically used when the parts being collected come from varied databases or putting them in a single query makes it difficult to compose the query.

.derivedTable Collection
image::derivedTablesCollection.png[Collection, align='center']

This part assembles the album part (Part A) and tracks part (Part B) with artist information for the main or final query.

  
NOTE: This request could be done using a single query.  The derived tables are being used here, 
to show how they can be used to build parts of the results, that are assembled in a main query later.

NOTE: Derived Tables are also know as sub-queries.  

  
.SQL Example
[source,sql]
----
include::{sqldir}/0006c-derivedTable.sql[]
----
<1> A column from the derived table (sub-query) being used in the result
<2> CAST being used to reformat a decimal number to 5,2.  Five digits total, two digits precision
<3> The beginning of a derived table (sub-query) starts with a `(`
<4> The end of the derived table (sub-query) is marked with a `)` and a name for the derived table.
The derived table name is used to qualify the use of the columns in the main query.
<5> This calculated or derived field is the sum of time (Milliseconds) for all tracks for this artist.
Dividing by 60,000.00 translates this into minutes.  
<6> This calculated or derived field is the average of the time (Milliseconds) for all tracks for this artist.
Dividing by 60,000.00 translate this into minutes.

SQL Download link link:{sqldir}/0006c-derivedTable.sql[ click here]
 
.Results
[options='header']
,===
include::{resultdir}/0006c-derivedTable.csv[Results,lines=1..20]
,===

NOTE: Only 20 rows of the result being shown.  The result set has 204 rows, one for each artist.

.Multiple SQL Selects
image::quote-single.png[Multiple SQL Selects, align='center']
 
Back to <<top>>.
 



//// 
******************  derivedTable2A  derivedTable2A  derivedTable2A  derivedTable2A      
////
<<<<
[[derivedTable2Parta]]
=== derivedTable 2 - Part A

*Objective:* The *Top Order Tracks* is a list of tracks from orders in a year that are $5 or more.  
What other tracks across all orders share a track from the *Top Order Tracks* list?

*Approach:* Use a set of derived tables (sub-queries) to create progressive filters to get the result

* Part A - List of invoices for one year that are $5 or more
* Part B - Get the list of tracks for the invoices in the Part A, this is the *Top Order Tracks* list
* Part C - Find all invoices that have a track from Part B the *Top order Tacks* list.
* Part D - Find all tracks, across all invoices, with a match in the *Top Order List* and count them

.derivedTable Filter
image::derivedTablesFilters.png[Filters]

NOTE: This request could be done using a single query.  The derived tables are being used here, 
to show how they can be used as a  filter or reduce the number of rows in the result.

NOTE: Derived Tables are also know as sub-queries.
  
.SQL Example
[source,sql]
----
include::{sqldir}/0007a-derivedTable.sql[]
----
<1> Fields used during the testing of the derived table (sub-query)
two hypens `--` used to comment out a line
<2> `between` function requires starting value `and` ending value
<3> `date` indicates a date field, Teradata standard format is `yyyy-mm-dd`
 
SQL Download link link:{sqldir}/0007a-derivedTable.sql[ click here]
 
.Results
[options='header']
,===
include::{resultdir}/0007a-derivedTable.csv[Results,lines=1..20]
,===

NOTE: Only 20 rows of the result being shown.  The result set has 35 rows, one for each invoice of $5 or more.

Back to <<top>>.
 



//// 
******************  derivedTable2B  derivedTable2B  derivedTable2B  derivedTable2B      
////
<<<<
[[derivedTable2Partb]]
=== derivedTable 2 - Part B

*Objective:* 

*Approach:* 

.derivedTable Filter
image::derivedTablesFilters.png[Filters]

NOTE: This request could be done using a single query.  The derived tables are being used here, 
to show how they can be used as a  filter or reduce the number of rows in the result.

NOTE: Derived Tables are also know as sub-queries.
  
.SQL Example
[source,sql]
----
include::{sqldir}/0007b-derivedTable.sql[]
----
<1> Derived Table (Sub-query) begins with a `(` then the sub-query SQL
<2> `between` function requires starting value `and` ending value
<3> `date` indicates a date field, Teradata standard format is `yyyy-mm-dd`
<4> The end of the derived table (sub-query) is marked with a `)` and a name for the derived table `RI` Reduced Invoices.
The derived table name is used to qualify the use of the columns in the main query.
<5> `DISTINCT` used to elminate duplicates, applied to the entire result set
 
SQL Download link link:{sqldir}/0007b-derivedTable.sql[ click here]
 
.Results
[options='header']
,===
include::{resultdir}/0007b-derivedTable.csv[Results,lines=1..20]
,===


NOTE: Only 20 rows of the result being shown.  The result set has 345 rows, one for each track of a 2018 morder of $5 or more.

Back to <<top>>.






//// 
******************  derivedTable2C  derivedTable2C  derivedTable2C  derivedTable2C      
////
<<<<
[[derivedTable2Partc]]
=== derivedTable 2 - Part C

*Objective:* 

*Approach:* 

.derivedTable Filter
image::derivedTablesFilters.png[Filters]

NOTE: This request could be done using a single query.  The derived tables are being used here, 
to show how they can be used as a  filter or reduce the number of rows in the result.

NOTE: Derived Tables are also know as sub-queries.
  
.SQL Example
[source,sql]
----
include::{sqldir}/0007c-derivedTable.sql[]
----
<1> `DISTINCT` used to eliminate duplicates, applied to the entire result set
<2>  Derived Table (Sub-query) begins with a `(` then the sub-query SQL
<3>  Derived Table (Sub-query) begins with a `(` then the sub-query SQL
<4>  The end of the derived table (sub-query) is marked with a `)` and a name for the derived table `RI` Reduced Invoices.
The derived table name is used to qualify the use of the columns in the main query.
<5> The end of the derived table (sub-query) is marked with a `)` and a name for the derived table `TL` Track List.
The derived table name is used to qualify the use of the columns in the main query.
<6> Filter for only tracks that match tracks in the `TL` trackList *Top OrderTrack* list
<7> `between` function requires starting value `and` ending value
<8> `date` indicates a date field, Teradata standard format is `yyyy-mm-dd`
 
SQL Download link link:{sqldir}/0007c-derivedTable.sql[ click here]
 
.Results
[options='header']
,===
include::{resultdir}/0007c-derivedTable.csv[Results,lines=1..20]
,===

NOTE: Only 20 rows of the result being shown.  The result set has ??? rows, one for each track of a 2018 morder of $5 or more.

Back to <<top>>.





//// 
******************  derivedTable2D  derivedTable2D  derivedTable2D  derivedTable2D      
////
<<<<
[[derivedTable2Partd]]
=== derivedTable 2 - Part D

.derivedTable Filter
image::derivedTablesFilters.png[Filters]

NOTE: This request could be done using a single query.  The derived tables are being used here, 
to show how they can be used as a  filter or reduce the number of rows in the result.

NOTE: Derived Tables are also know as sub-queries.
  
.SQL Example
[source,sql]
----
include::{sqldir}/0007d-derivedTable.sql[]
----
<1> column alias
<2> derived column with column alias
<3> The beginning of a derived table (sub-query) starts with a `(`
<4> `DISTINCT` used to eliminate duplicates, applied to the entire result set
<5> The beginning of a derived table (sub-query) starts with a `(`
<6> The beginning of a derived table (sub-query) starts with a `(`
<7> `between` function requires starting value `and` ending value
<8> `date` indicates a date field, Teradata standard format is `yyyy-mm-dd`
<9> The end of the derived table (sub-query) is marked with a `)` and a name for the derived table `RI` Reduced Invoices.
The derived table name is used to qualify the use of the columns in the main query.
<10> The end of the derived table (sub-query) is marked with a `)` and a name for the derived table `TL` Track List.
The derived table name is used to qualify the use of the columns in the main query.
<11> The end of the derived table (sub-query) is marked with a `)` and a name for the derived table `SI` Special Invoices.
The derived table name is used to qualify the use of the columns in the main query.
<12> `Group by` required for any column that is not an aggregate column
<13> `trackCount` is a column alias of a derived column (Count) used here for sorting
<14> `trackName` is a column alias
<15> `having` is a filter for a aggregate column

 
SQL Download link link:{sqldir}/0007d-derivedTable.sql[ click here]
 
.Results
[options='header']
,===
include::{resultdir}/0007d-derivedTable.csv[Results,lines=1..20]
,===

NOTE: Only 20 rows of the result being shown.  The result set has 88 rows, one for each track of an order with a matching track in the *Top Order Track* list.

Back to <<top>>.






//// 
******************  createView   createView   createView   createView  
//// 
<<<<
[[createView]]

=== Create View

A view is a database object  is built from other database objects like tables and views.

Views can help give you a simpler viewable version of a complex query.

Views can help you reuse a standard copy of a database object across queries.

Unlike a table which takes up permanent space for its data, a view does not take up permanent space.

NOTE: To create views in your database area you will need to have `Perm Space` assigned to your account.


==== Example

In the Chinook database many of the queries require comprehensive Album information.

The Album view with comprehensive album information we need join data from five different tables.

.vAlbum Relationships
image::vAlbumRelationships.png[vAlbum Relationships, align='center']
 
  
.SQL Example
[source,sql]
----
include::{sqldir}/0100-create-vAlbumView.sql[]
----
<1> The first time a view is built use the `Create` statement
<2> To change an existing view use the `update` statement
<3> Column Alias in order avoid confusion with the field `name`
<4> Derived Column (aka Calculated Column) notice the 60000.00 has two zeros of precision in order to return a decimal number
<5> Derived Column (aka Calculated Column) notice the 1048576.00 has two zeros of precision in order to return a decimal number
<6> Table alias, each joined table has it own unique table alias.  

NOTE: In this example the `Album` table was chosen as the main table of the view.
 
SQL Download link link:{sqldir}/0100-create-vAlbumView.sql[ click here]
 
If you didn't create the view then you may not know the column names of the view.

To display a list of the `vAlbum` view columns use

   help view vAlbum  


The column list of the view will be returned.

.Display View Columns
image::vAlbumHelp.png[Display View Columns, align='center']
 
This column list may be sufficient enough for you to use the view in your work.

If you need more knowledge about how the vAlbum view was built use

  show view vAlbum

The SQL statement used to create the vAlbum view will be returned.

.Display View SQL
image::vAlbumShow.png[Display View SQL, align='center']
 
NOTE: Any bulk comments `/* comments \*/` will have been stripped out by Teradata when the view is created or updated.

.Longest Query Rewards
image::quote-longest.png[Longest Query Rewards, align='center']
 
Back to <<top>>.
 




//// 
******************  dateFilters     dateFilters   dateFilters   dateFilters   dateFilters   
////  
<<<<
[[dateFilters]]
=== Date Filters
  
The Teradata `extract` function provides month, day and year.

The Teradata `Csum` OLAP function is used for the running totals.

Csum( `column to sum`, `Column to sum by` ).

This query displays a cumulative sum (Running total) of the sales occurring during the "Bargain Days".
"Bargain Days" are the first week of September thru December for 2018.

.SQL Example
[source,sql,linenums]
----
include::{sqldir}/0012-dateFilters.sql[]
----
<1> Column Alias
<2> Date function `Extract` 
<3> OLAP Csum
<4> Table alias


SQL Download link link:{sqldir}/0012-dateFilters.sql[ click here]
 
.Results
[options='header']
,===
include::{resultdir}/0012-dateFilters.csv[Results]
,===
 
Back to <<top>>.
 




//// 
******************  ranking   ranking   ranking   ranking   ranking   
////  
<<<<
<<<<
[[ranking]]
=== Ranking

Ranking is a combination of sorting the results and assigning an ordinal number corresponding to the rank for the result.  Similar ranked numbers share the ordinal number assigned to them.

The Teradata `Rank` function uses just one argument, the column you want to rank by.

NOTE: The `Rank` function and aggregate functions can not be a single select query.

In this query we want 

* Ranking of *Genre* by the number of `Sales`.   
* A `Sale` relates to an single *InvoiceLineItem*.
* Each *InvoiceLineItem* is related to a *Track* which has the *Genre* information
* So an *Invoice* with 6 *InvoiceLineItems* counts as a `Sale` count of 6
  
.SQL Example
[source,sql,linenums]
----
include::{sqldir}/0014-rank.sql[]
----
<1> Column alias
<2> OLAP function Rank
<3> Aggregate function Count
<4> Table alias
<5> Column Alias for group by
<6> Derived Table (Sub-query) named `GC` for genreCounts

NOTE: Because the `GC` columns come from a derived table they can be used in `group by`.
The restriction is that the Table alias `GC` can *NOT* be part of the column name.

NOTE: Because `Rank` is automatically doing the `Order by` based on the column in the `Rank` statement.
Do *NOT* add an additional `order by` the results will be incorrect.

 
SQL Download link link:{sqldir}/0014-rank.sql[ click here]
 
.Results
[options='header']
,===
include::{resultdir}/0014-rank.csv[Results]
,===
<1>

NOTE: The Genre's `Sci Fi & Fantasy` and `Soundtrack` share ranking number `13` because they both have a `saleCount` of `20`.  There are two other shared ranking numbers `19` and `23`
 
Back to <<top>>.
 





////
*******************************************************************
  _______ _           
 |__   __(_)          
    | |   _ _ __  ___ 
    | |  | | '_ \/ __|
    | |  | | |_) \__ \
    |_|  |_| .__/|___/
           | |        
           |_|        
********************************************************************
////
<<<<
== Tips 

This tips can  be considered suggestions to make developing SQL a little bit easier.

=== Aggregate Functions

These functions are  used to compress or limit the number of rows into a single row.

* `Count(?)` Counts the number of rows, duplicates included in the count.
* `Count Distinct(?)` Count the number of rows, duplicates only counted once.
* `Sum(?)` Sums the values in the column, the column must be a numeric column.

=== Column Alias

* Column alias help to give meaningful, non conflicting names. 
* Good practice, alias column names use lowerUpper naming 
to identify them as alias (ie: albumCount, salesDollars, genreAverage)
* Good practice, try to use the same column alias across all queries.


=== Dates

* Default Teradata date format is `yyyy-mm-dd`
* Convert a string into a date with `DATE` function  (DATE '2018-01-01')
* Extract parts of a date with the `EXTRACT` function (EXTRACT MONTH I.InvoiceDate)


=== Derived Tables (Sub-Queries)

* Start with a regular query until you get the results you need.
* Enclose the regular query in `(...)` and assign a table alias name.
* Good practice is to start a derived table with a `(` on a line by itself.
* Good practice is to end a derived table with a `( as XX` on a line by itself
* Good practice is to indent the derived table within the `(` and `) as XX`



=== Formatting / Conversion

* `Cast(x,y)` can be used to reduce number of digits of precision.

X=Number of digits on both sides of the decimal point totaled (ie: 999.99 X=5)

Y=Number of digits of precision, number og digits to the right of the decimal point. 
(ie: 999.99 Y=2) 


=== Join

* The `Left` table is defined by the first `Select` in the query.
* The `Right` table is defined by the object in the `Join` clause.
* The `Inner Join` returns results where there is a matching column in both Left and Right tables.
* The `Outer Join` returns *ALL* results from one table and any matching results from the other table.
* The *ALL* table is determined by the direction of the `Outer join` (Left Outer Join, Right Outer Join).



=== Naming practice

* Good practice, System Generated Primary Index column name  
include a `ID` suffix (AlbumID, TrackID).
* Good practice, Primary Key and Foreign Key join columns 
should use the same name.
* Short descriptive column names are better than abbreviations.


=== OLAP Functions

* `CSUM` uses two arguments.  First argument is the column to be summed, the second argument is the column to `sum by`.
* `Rank` only has one argument.  This argument is the field to be ranked.  Duplicate values in this argument will share a ranking number.  `Rank` automatically performs an `order by`.


=== Order By

* Can use actual column name (T.Milliseconds, I.InvoiceDate), column alias name (trackCount, genreName), or ordinal position (1,2,3,4).
* Good practice is to avoid using ordinal position because as queries change the number and order of select columns, the results can become invalid.


=== Select columns

* Use single quote `'` to denote text.
* Use double-quotes `"` for renaming objects.
* Indent columns selected. 
* Limit one column per row.
* Put commas at the beginning of the column name, not at the end, starting on the 2nd column.

.Not recommended
[source, sql]
----
Select
    T.Name as trackName,
    I.InvoiceDate,
    AL.Name as albumName,
    count(T.TackID) as trackCount,
----

.Recommended
[source, sql]
----
Select
    T.Name as trackName
    ,I.InvoiceDate
    ,AL.Name as albumName
    ,count(T.TackID) as trackCount
----


=== Table Alias

* Table alias shorten the typing needed to complete the query, 
1-3 character alias recommended.
* Use the same table alias across all queries.
* Good practice is to have table alias used everywhere in the query, including Select, From, Join, Where, Group By and Order By.
* Good Practice is to have table alias be uppercase (IE: I, IL, T, G)



=== Teradata Specific

* Teradata will look for any `Primary Index` specified in the DDL. 
*  If a `Primary Index` is not specified, it will then look for `Primary Key` constraint in DDL
 for making it `Primary Index`.


=== Union

* UNION allows joining of multiple queries
* Each queries must have same number and data type of columns.
* First query in union determine sizes and names of columns.
* Start small and build on to the Union query.


=== Where

* Good practice, put `and` where clauses on separate lines
* Good practice, put `or` where clause on single line
* Use `(..)` to help clarify logical groupings


<<<<
== Contact Information

Author contact Information

*Email:* schusterj@Michigan.gov

*Email:* john.schuster@PhoenixWorkgroup.com

*Phone:*  517-927-7400

NOTE: Please provide any feedback, corrections or suggestions to the author.  The folks providing the most amount of feedback will win prizes.


////
*********************************************************************
  _____       __                             
 |  __ \     / _|                            
 | |__) |___| |_ ___ _ __ ___ _ __   ___ ___ 
 |  _  // _ \  _/ _ \ '__/ _ \ '_ \ / __/ _ \
 | | \ \  __/ ||  __/ | |  __/ | | | (_|  __/
 |_|  \_\___|_| \___|_|  \___|_| |_|\___\___|
                                             
                                             
**********************************************************************
//// 
<<<<
== Reference

This reference material and links may change over time.  

If you get a broken link use your GoogleFoo to locate the material.

=== Related Links

Database 5 Pro SQL Tool: https://fishcodelib.com/database.htm[https://fishcodelib.com/database.htm]

DBeaver SQL Tool: https://dbeaver.io/[https://dbeaver.io/]

Stack Overflow (Teradata Forum): https://stackoverflow.com/questions/tagged/teradata[https://stackoverflow.com/questions/tagged/teradata, window='_blank']

=== Teradata links

Documentation: https://docs.teradata.com/landing-page/[https://docs.teradata.com/landing-page/, window='_blank']

Forum: https://community.teradata.com/[https://community.teradata.com/, window='_blank']

SQL Assistant: https://bit.ly/2LYpXxB[window='_blank']

SQL Introduction: https://bit.ly/2Fhxp5C[window='_blank']

Teradata Studio: http://downloads.teradata.com/download/tools/teradata-studio[http://downloads.teradata.com/download/tools/teradata-studio]

Teradata Tools and Utilities (TTU): https://downloads.teradata.com/download/tools/teradata-tools-and-utilities-windows-installation-package[https://downloads.teradata.com/download/tools/teradata-tools-and-utilities-windows-installation-package]

=== Chinook database creation

The Teradata script used to create the Chinook database is avaliable at this link:{sqldir}/0000-createDatabaseLocal.sql[ link.]


=== Column Type

ColumnType reference table.
Reference: http://developer.teradata.com/doc/connectivity/tdnetdp/14.00/webhelp/DataTypeMappings.html

.ColumnType
[cols="^3,8" options='header']
,===
include::{docodir}/column-type.csv[ColumnType]
,===

 

 

 
////
*******************************************************************************************
  _____                                        _     _    _ _     _                   
 |  __ \                                      | |   | |  | (_)   | |                  
 | |  | | ___   ___ _   _ _ __ ___   ___ _ __ | |_  | |__| |_ ___| |_ ___  _ __ _   _ 
 | |  | |/ _ \ / __| | | | '_ ` _ \ / _ \ '_ \| __| |  __  | / __| __/ _ \| '__| | | |
 | |__| | (_) | (__| |_| | | | | | |  __/ | | | |_  | |  | | \__ \ || (_) | |  | |_| |
 |_____/ \___/ \___|\__,_|_| |_| |_|\___|_| |_|\__| |_|  |_|_|___/\__\___/|_|   \__, |
                                                                                 __/ |
                                                                                |___/ 
********************************************************************************************
////

<<<<
== Document History

.Document History
[cols='2,2,2,6' options='header']
|===
| Date  | Version | Author | Description
| 01/11/2019 | V2.1n | JHRS | Added view updates, dateFunctions, SQL Tool info
                              title 'Learning Guide'
| 01/10/2019 | V2.1M | JHRS | Moved Tips from SQL queries to make them smaller
                              and avoid sync issues, fixed join definitions
                              updated derived query B
| 01/09/2019 | v2.1k | JHRS | Added View and join types, plaques
| 01/08/2018 | V2.1j | JHRS | Updated Chinook introduction
| 01/03/2019 | V2.1h | JHRS | Added derived Table for Filters
                              Added diagrams for derived tables
| 01/02/2019 | V2.1g | JHRS | Updated derived query for collections
| 12/28/2018 | V2.1f | JHRS | Added derivedQuery from archived
| 12/27/2018 | V2.1e | JHRS | Added joinQuery set from archive
| 12/21/2018 | V2.1d | JHRS | Added vsCode snippet for quick query insert
                              added Reference section
| 12/20/2018 | V2.1c | JHRS | Attempting standard document template
| 12/17/2018 | V2.1b | JHRS |  Initial version
|===




////
Internal Document notes:

1. The SQL included code will not have line numbers, this is ok.

2. Use the SQL callout syntax --<1> at the end of line, then add <1> This is what this does under the SQL code block

3. Use directives for documents (docdir), SQL folder (sqldir} and Results folder {resultdir}, this allows for better separation os objects and allows for libraries to be redirected.

4. Because of section numbering the standard section link <<section>> doesn't work.  So section headers that need to be an anchor need to have a [[section]] above the section




////



